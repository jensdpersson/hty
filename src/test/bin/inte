#!/usr/bin/env escript

basedir() -> "src/test/inte/".
    
select(Xpath, Node, Doc) ->
    xmerl_xpath:string(Xpath, Node, [], Doc, []).
text({xmlText, _, _, _, Text, _}) -> 
    Text;
text({xmlElement,_,_,_,_,_,_,_,[XmlText], _, _, _}) -> 
    text(XmlText).
attr({xmlAttribute, _, _, _, _, _, _, _, Value, _}) ->
    Value.
tagname({xmlElement,TagName,_,_,_,_,_,_,_,_, _, _}) -> 
    TagName. 

read(Elm, Doc, Dir) ->
    case select("@file", Elm, Doc) of
	[] ->
	    text(Elm);
	[Attr] ->
	    case file:read_file(filename:join(Dir, attr(Attr))) of
		{ok, Binary} ->
		    binary_to_list(Binary);
		{error, Error} ->
		    {error, Error}
	    end
    end.

check_asserts(Response, Asserts, Doc, Testdir, TestID) ->
    MakeCheck = 
	fun(Assert) ->
		Target = case tagname(Assert) of
			     status ->
				 integer_to_list(element(2, element(1, Response)));
			     header ->
				 Headers = element(2, Response),
				 [Attr] = select("@name", Assert, Doc),
				 Header = attr(Attr),
				 case lists:keyfind(Header, 1, Headers) of
				     false ->
					 undefined;
				     {_Name, Value} ->
					 Value
				 end;
			     body ->
				 element(3, Response)
			 end,
		Elmer = fun(Elm) -> 
				{tagname(Elm), read(Elm, Doc, Testdir), Target, atom_to_list(tagname(Assert))}
			end,
		case select("*|text()", Assert, Doc) of
		    [One] ->
			case element(1, One) of
			    xmlElement ->
				[Elmer(One)];
			    xmlText ->
				[{exact, text(One), Target, atom_to_list(tagname(Assert))}]
			end;
		    Several ->
			lists:map(fun(Elm) ->
					  case element(1, Elm) of
					      xmlElement -> 
						  Elmer(Elm);
					      _ ->
						  []
					  end
				  end, Several)
		end
	end,
    Checks = lists:flatten(lists:map(MakeCheck, select("*", Asserts, doc))),
    lists:map(fun(Check) -> 
		      case Check of
			  {exact, A, A, AssertName} ->
			      {pass, TestID, AssertName};
			  {exact, A, B, AssertName} ->
			      {fail, TestID, AssertName, A, B};
			  Unknown ->
			      {fail, TestID, unknown, Unknown}
		      end
	      end, Checks).


run_test(Fixturedir, Test) ->
    Testdir = filename:join([Fixturedir, "tests", Test]),
    io:format("Running test ~p in ~p~n",[Test, Testdir]),
    Specfile = filename:join(Testdir, "testspec.xml"),
    Profile = list_to_atom(Test),
    {ok, HttpcPid} = inets:start(httpc, [{profile, Profile}]),
    {Doc, _} = xmerl_scan:file(Specfile),
    Transactions = xmerl_xpath:string("/testspec/transaction", Doc),
    [Results] = lists:map(fun(Tx) ->
				[Request] = select("request", Tx, Doc),
				Method = case select("method", Request, Doc) of
					     [] ->
						 get;
					     Elm ->
						 text(Elm)
					 end,
				UrlOrError = case select("url", Request, Doc) of
					  [] -> {error, url_element_missing};
					  [UrlElement] -> {ok, text(UrlElement)}
				      end,
				Headers = lists:map(fun(HeaderElm) -> 
							    Attr = select("@name", HeaderElm, Doc),
							    apa = HeaderElm,
							    {}
						    end,
						    select("header", Request, Doc)),
				EntityOrError = case select("body", Request, Doc) of
					     [Body] ->
						 case select("@file", Body, Doc) of
						     [Attr] ->
							 File = attr(Attr),
							 file:read_file(File);
						     _ ->
							 {ok, <<"">>}
						 end;
					     [] ->
						 {ok, <<"">>}
					 end,
				case {EntityOrError, UrlOrError} of
				    {{ok, Entity},{ok, Url}} ->
					Req = case Entity of
						  <<"">> ->
						      {Url, Headers};
						  NonEmpty ->
						      ContentType = 
							  lists:keyfind("Content-Type", 1, Headers),
						      {Url, Headers, ContentType, NonEmpty}
					      end,
					case httpc:request(Method, Req, [], [], Profile) of
					    {error, Error} ->
						{error, Error};
					    {ok, HttpResponse} ->
						[ResponseAsserts] = select("response", Tx, Doc),
						check_asserts(HttpResponse, ResponseAsserts, Doc, Testdir, Test)
					end;
				    {{error, EntityError}, {error, UrlError}} ->
					{error, [EntityError, UrlError]} ;
				    {{error, Error}, _} ->
					{error, Error};
				    {_, {error, Error}} ->
					{error, Error}
				end
			end, Transactions),
    inets:stop(httpc, HttpcPid),
    lists:foreach(fun({pass, Test, Assert}) ->
		       io:format("PASS ~p~n", [Test ++ "/" ++ Assert]);
		  ({fail, Test, Assert, Expected, Actual}) ->
		       io:format("FAIL ~p, expected '~p' but got '~p'~n", [Test ++ "/" ++ Assert, Expected, Actual])
	       end, Results).

	    
run_fixture(Fixture) ->
    io:format("About to start fixture ~p~n", [Fixture]),
    Fixturedir = basedir() ++ Fixture,
    Etcdir = filename:join(["src", "test", "inte", Fixture, "etc"]),
    case hty_ctl:start([Etcdir]) of
	{ok, Status} ->
	    io:format("Fixture ~p got OK status ~p~n", [Fixture, Status]),
	    {ok, Tests} = file:list_dir(filename:join(Fixturedir, "tests")),
	    lists:foreach(fun(Test) ->
				  run_test(Fixturedir, Test)
			  end, Tests), 
	    hty_ctl:stop();
	{error, Error} ->
	    io:format("Fixture ~p got error ~p for etc folder ~p ~n", [Fixture, Error, Etcdir])
    end.

main([]) ->
    Basedir = basedir(),
    inets:start(),
    code:add_pathz("target/ebin"),
    case file:list_dir(Basedir) of
	{ok, Fixtures} ->
	    io:format("Found these fixtures: ~p~n", [Fixtures]),
	    lists:foreach(fun(Fixture) -> 
				  io:format("Fixture ~p ~p~n", [Fixture, catch run_fixture(Fixture)])
			  end, Fixtures);
	{error, Error} ->
	    io:format("Failed running fixtures in ~p, got error ~p~n", [Basedir, Error])
    end,
    inets:stop().
	    
