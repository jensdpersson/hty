#!/usr/bin/env escript

basedir() -> "src/test/inte/".

select(Xpath, Node, Doc) ->
    xmerl_xpath:string(Xpath, Node, [], Doc, []).
text({xmlText, _, _, _, Text, _}) ->
    Text;
text({xmlElement,_,_,_,_,_,_,_,[XmlText], _, _, _}) ->
    text(XmlText).
attr({xmlAttribute, _, _, _, _, _, _, _, Value, _}) ->
    Value.
tagname({xmlElement,TagName,_,_,_,_,_,_,_,_, _, _}) ->
    TagName.

read(Elm, Doc, Dir) ->
    case select("@file", Elm, Doc) of
	[] ->
	    text(Elm);
	[Attr] ->
	    case file:read_file(filename:join(Dir, attr(Attr))) of
		{ok, Binary} ->
		    binary_to_list(Binary);
		{error, Error} ->
		    {error, Error}
	    end
    end.

check_asserts(Response, Asserts, Doc, Testdir, TestID) ->
    MakeCheck =
	fun(Assert) ->
		Target = case tagname(Assert) of
			     status ->
				 integer_to_list(element(2, element(1, Response)));
			     header ->
				 Headers = element(2, Response),
				 [Attr] = select("@name", Assert, Doc),
				 Header = attr(Attr),
				 case lists:keyfind(Header, 1, Headers) of
				     false ->
					 undefined;
				     {_Name, Value} ->
					 Value
				 end;
			     body ->
				 element(3, Response)
			 end,
		Elmer = fun(Elm) ->
				{tagname(Elm), read(Elm, Doc, Testdir), Target, atom_to_list(tagname(Assert))}
			end,
		case select("*|text()", Assert, Doc) of
		    [One] ->
			case element(1, One) of
			    xmlElement ->
				[Elmer(One)];
			    xmlText ->
				[{exact, text(One), Target, atom_to_list(tagname(Assert))}]
			end;
		    Several ->
			lists:map(fun(Elm) ->
					  case element(1, Elm) of
					      xmlElement ->
						  Elmer(Elm);
					      _ ->
						  []
					  end
				  end, Several)
		end
	end,
    Checks = lists:flatten(lists:map(MakeCheck, select("*", Asserts, doc))),
    lists:map(fun(Check) ->
		      case Check of
			  {exact, A, A, AssertName} ->
			      {pass, TestID, AssertName};
			  {exact, A, B, AssertName} ->
			      {fail, TestID, AssertName, A, B};
			  Unknown ->
			      {fail, TestID, unknown, Unknown}
		      end
	      end, Checks).


run_test(Fixturedir, Test) ->
    Testdir = filename:join([Fixturedir, "tests", Test]),
    io:format("Running test ~p in ~p~n",[Test, Testdir]),

    Specfile = filename:join(Testdir, "testspec.xml"),
    Profile = list_to_atom(Test),
    {ok, HttpcPid} = inets:start(httpc, [{profile, Profile}]),
    {Doc, _} = xmerl_scan:file(Specfile),
    Transactions = xmerl_xpath:string("/testspec/transaction", Doc),
    [Results] = lists:map(fun(Tx) ->
				[Request] = select("request", Tx, Doc),

        Method = case select("method", Request, Doc) of
					         [] ->
						         get;
					         Elm ->
						         text(Elm)
					       end,

				UrlOrError = case select("url", Request, Doc) of
					  [] ->
              {error, url_element_missing};
					  [UrlElement] ->
              {ok, text(UrlElement)}
				  end,

				Headers = lists:map(fun(HeaderElm) ->
					  		    Attr = select("@name", HeaderElm, Doc),
						  	    apa = HeaderElm,
							      {}
						        end,
						        select("header", Request, Doc)),
				EntityOrError = case select("body", Request, Doc) of
					[Body] ->
					  case select("@file", Body, Doc) of
						  [Attr] ->
							  File = attr(Attr),
							  file:read_file(File);
						  _ ->
							 {ok, <<"">>}
					  end;
					[] ->
					  {ok, <<"">>}
					end,
				case {EntityOrError, UrlOrError} of
				    {{ok, Entity},{ok, Url}} ->
					Req = case Entity of
						  <<"">> ->
						      {Url, Headers};
						  NonEmpty ->
						      ContentType =
							  lists:keyfind("Content-Type", 1, Headers),
						      {Url, Headers, ContentType, NonEmpty}
					      end,
					case httpc:request(Method, Req, [], [], Profile) of
					    {error, Error} ->
						{error, Error};
					    {ok, HttpResponse} ->
						[ResponseAsserts] = select("response", Tx, Doc),
						check_asserts(HttpResponse, ResponseAsserts, Doc, Testdir, Test)
					end;
				    {{error, EntityError}, {error, UrlError}} ->
					{error, [EntityError, UrlError]} ;
				    {{error, Error}, _} ->
					{error, Error};
				    {_, {error, Error}} ->
					{error, Error}
				end
			end, Transactions),
    inets:stop(httpc, HttpcPid),

    {testresult, Testdir, Results}.


run_fixture(Fixture) ->
    io:format("About to start fixture ~p~n", [Fixture]),
    Fixturedir = basedir() ++ Fixture,
    Etcdir = filename:join(["src", "test", "inte", Fixture, "etc"]),
    case hty_ctl:start([Etcdir]) of
	     {ok, Status} ->
          TestFolder = filename:join(Fixturedir, "tests"),
	        io:format("Fixture ~p got OK status ~p, looking for tests in ~p~n", [Fixture, Status, TestFolder]),
          case file:list_dir(TestFolder) of
            {ok, Tests} ->
              io:format("Found these tests ~p~n", [Tests]),
	             TestResults = lists:map(fun(Test) ->
				             run_test(Fixturedir, Test)
			        end, Tests),
	            hty_ctl:stop(),
              {Fixture, TestResults};
            {error, enoent} ->
              io:format("Found no tests in ~p~n", [TestFolder]),
              {Fixture, []}
          end;
	{error, Error} ->
	    io:format("Fixture ~p got error ~p for etc folder ~p ~n", [Fixture, Error, Etcdir]),
      {error, Error}
    end.

main([Outfile]) ->
    Basedir = basedir(),
    inets:start(),
    code:add_pathz("target/ebin"),
    FixtureResults = case file:list_dir(Basedir) of
	     {ok, Fixtures} ->
	        io:format("Found these fixtures: ~p~n", [Fixtures]),
	        lists:map(fun(Fixture) ->
                FixtureResult = run_fixture(Fixture),
				        io:format("Fixture ~p ~p~n", [Fixture, FixtureResult]),
                FixtureResult end, Fixtures);
	     {error, Error} ->
	        io:format("Failed running fixtures in ~p, got error ~p~n", [Basedir, Error]),
          {error, Error}
    end,
    {ok, Out} = file:open(Outfile, [write]),

    WriteTestResult = fun(A) ->
      {testresult, TestName, TestResults} = A,
      file:write(Out, [<<"<test path=\"">>, TestName, <<"\">">>]),
      foreach(TestResults, fun(TestResult) ->
      case TestResult of
        {pass, Test, Assert} ->
          file:write(Out, [<<"<pass assert=\"">>, [Test ++ "/" ++ Assert], <<"\"/>">>]);
        {fail, Test, Assert, Expected, Actual} ->
          file:write(Out, [<<"<fail assert=\"">>, [Test ++ "/" ++ Assert], <<"\">">>]),
          file:write(Out, [<<"<expected>">>,Expected,<<"</expected>">>]),
          file:write(Out, [<<"<actual>">>,Actual,<<"</actual>">>]),
          file:write(Out, [<<"</fail>">>])
      end
    end),
      file:write(Out, [<<"</test>">>])
    end,

    WriteFixture = fun(A) ->
      {Fixture, TestResults} = A,
      file:write(Out, [<<"<fixture path=\"">>, Fixture, <<"\">">>]),
      lists:foreach(WriteTestResult, TestResults),
      file:write(Out, <<"</fixture>">>)
    end,

    %file:write(Out, <<"<?xml-stylesheet type=\"text/xsl\" href=\"fixture2html.xsl\"?>">>),
    file:write(Out, <<"<fixtures>">>),
    lists:foreach(WriteFixture, FixtureResults),
    file:write(Out, <<"</fixtures>">>),
    file:close(Out),
    inets:stop().


foreach(List, Fun) -> lists:foreach(Fun, List).
